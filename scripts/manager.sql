/* 
 * 
 * Script de criação da BD Manager
 * 
 */
 
set escape on;

/* TABLES */

CREATE TABLE STATUS (
      STATUS_KEY NUMBER NOT NULL,
      UPTIME NUMBER NOT NULL,
      DATABASE_TYPE VARCHAR2(15) NOT NULL,
      DATABASE_NAME VARCHAR2(9) NOT NULL,
      INSTANCE_NAME VARCHAR2(16) NOT NULL,
      CONTAINERS_NAME VARCHAR2(30) NOT NULL,
      PLATFORM_NAME VARCHAR2(101) NOT NULL,
      THREAD# NUMBER NOT NULL,
      ARCHIVER VARCHAR2(7) NOT NULL,
      TSTAMP TIMESTAMP NOT NULL,
      CONSTRAINT pk_status_key PRIMARY KEY (STATUS_KEY),
      CONSTRAINT database_type_value CHECK (DATABASE_TYPE IN ('RAC', 'RACONENODE', 'SINGLE', 'UNKNOWN')),
      CONSTRAINT archiver_value CHECK (ARCHIVER IN ('STOPPED', 'STARTED', 'FAILED'))
);

CREATE TABLE "TABLESPACE" (
      TABLESPACE_KEY NUMBER NOT NULL,
      TABLESPACE_ID NUMBER NOT NULL,
      TABLESPACE_NAME VARCHAR2(30) NOT NULL,
      TABLESPACE_SIZE NUMBER,
      FREE_SPACE NUMBER,
      USER_PERCENT NUMBER,
      MAX_SIZE NUMBER NOT NULL,
      STATUS VARCHAR2(9) NOT NULL,
      CONTENTS VARCHAR2(9) NOT NULL,
      SEGMENT_SPACE_MANAGEMENT VARCHAR2(6) NOT NULL,
      TSTAMP TIMESTAMP NOT NULL,
      CONSTRAINT pk_tablespace_key PRIMARY KEY (TABLESPACE_KEY),
      CONSTRAINT status_value CHECK (STATUS IN ('ONLINE', 'OFFLINE', 'READ ONLY')),
      CONSTRAINT contents_value CHECK (CONTENTS IN ('UNDO', 'PERMANENT', 'TEMPORARY')),
      CONSTRAINT seg_space_mang_value CHECK (SEGMENT_SPACE_MANAGEMENT IN ('MANUAL', 'AUTO'))
);

CREATE TABLE DATAFILE (
  DATAFILE_KEY NUMBER NOT NULL,
  DATAFILE_ID NUMBER NOT NULL,
    TABLESPACE_KEY NUMBER NOT NULL,
  DATAFILE_NAME VARCHAR2(513) NOT NULL,
  STATUS VARCHAR2(9) NOT NULL,
  "SIZE" NUMBER NOT NULL,
  MAX_SIZE NUMBER NOT NULL,
  AUTO_EXTENSIBLE VARCHAR2(3) NOT NULL,
  TSTAMP TIMESTAMP NOT NULL,
  CONSTRAINT pk_datafile_key PRIMARY KEY (DATAFILE_KEY),
    CONSTRAINT fk_datafile_tablespace FOREIGN KEY (TABLESPACE_KEY) REFERENCES "TABLESPACE" (TABLESPACE_KEY),
  CONSTRAINT datafile_status_value CHECK (STATUS IN ('AVAILABLE', 'INVALID'))
);

CREATE TABLE "USER"(
      USER_KEY NUMBER NOT NULL,
      USER_ID NUMBER NOT NULL,
      USERNAME VARCHAR2(128) NOT NULL,
      ACCOUNT_STATUS VARCHAR2(32) NOT NULL,
      EXPIRY_DATE DATE,
      DEFAULT_TABLESPACE VARCHAR2(30) NOT NULL,
      TEMPORARY_TABLESPACE VARCHAR2(30) NOT NULL,
      PROFILE VARCHAR2(128) NOT NULL,
      CREATED DATE,
      LAST_LOGIN TIMESTAMP(9) WITH TIME ZONE,
      TSTAMP TIMESTAMP NOT NULL,
      CONSTRAINT pk_user_key PRIMARY KEY (USER_KEY),
      CONSTRAINT acc_status_value CHECK (ACCOUNT_STATUS IN ('OPEN', 'EXPIRED', 'EXPIRED(GRACE)', 'LOCKED(TIMED)', 'LOCKED', 'EXPIRED \& LOCKED(TIMED)', 'EXPIRED(GRACE) \& LOCKED(TIMED)', 'EXPIRED \& LOCKED', 'EXPIRED(GRACE) \& LOCKED'))
);

CREATE TABLE USER_TABLESPACE(
      USER_TABLESPACE_KEY NUMBER NOT NULL,
      USER_KEY NUMBER NOT NULL,
      TABLESPACE_KEY NUMBER NOT NULL,
      USED_QUOTA NUMBER NOT NULL,
      QUOTA NUMBER NOT NULL,
      TSTAMP TIMESTAMP NOT NULL,
      CONSTRAINT pk_user_tablespace_key PRIMARY KEY (USER_TABLESPACE_KEY),
      CONSTRAINT fk_ut_user FOREIGN KEY (USER_KEY) REFERENCES "USER" (USER_KEY),
      CONSTRAINT fk_ut_tablespace FOREIGN KEY (TABLESPACE_KEY) REFERENCES "TABLESPACE" (TABLESPACE_KEY)
);

CREATE TABLE ROLE(
      ROLE_KEY NUMBER NOT NULL,
      ROLE_ID NUMBER NOT NULL,
      ROLE VARCHAR2(128) NOT NULL,
      AUTHENTICATION_TYPE VARCHAR2(11) NOT NULL,
      TSTAMP TIMESTAMP NOT NULL,
      CONSTRAINT pk_role_key PRIMARY KEY (ROLE_KEY),
      CONSTRAINT aut_type_value CHECK (AUTHENTICATION_TYPE IN ('NONE', 'EXTERNAL', 'GLOBAL', 'APPLICATION', 'PASSWORD'))
);

CREATE TABLE USER_ROLE(
      USER_ROLE_KEY NUMBER NOT NULL,
      USER_KEY NUMBER NOT NULL,
      ROLE_KEY NUMBER NOT NULL,
      TSTAMP TIMESTAMP NOT NULL,
      CONSTRAINT pk_user_role_key PRIMARY KEY (USER_ROLE_KEY),
      CONSTRAINT fk_ur_user FOREIGN KEY (USER_KEY) REFERENCES "USER" (USER_KEY),
      CONSTRAINT fk_ur_role FOREIGN KEY (ROLE_KEY) REFERENCES ROLE (ROLE_KEY)
);

CREATE TABLE SQL_COMMANDS(
      SQL_COMMANDS_KEY NUMBER NOT NULL,
      SQL_ID VARCHAR2(13) NOT NULL,
      SQL_FULLTEXT CLOB NOT NULL,
      TSTAMP TIMESTAMP NOT NULL,
      CONSTRAINT pk_sql_commands_key PRIMARY KEY (SQL_COMMANDS_KEY)
);

CREATE TABLE CPU(
      CPU_KEY NUMBER NOT NULL,
      NUM_CPUS NUMBER NOT NULL,
      IDLE_TIME NUMBER NOT NULL,
      BUSY_TIME NUMBER NOT NULL,
      IOWAIT_TIME NUMBER NOT NULL,
      USED_PERCENT NUMBER NOT NULL,
      TSTAMP TIMESTAMP NOT NULL,
      CONSTRAINT pk_cpu_key PRIMARY KEY (CPU_KEY)
);

CREATE TABLE MEMORY(
     MEM_KEY NUMBER NOT NULL,
     TOTAL_SIZE NUMBER NOT NULL,
     FREE_SPACE NUMBER NOT NULL,
     USED_SPACE NUMBER NOT NULL,
     USED_PERCENTE NUMBER NOT NULL,
     TSTAMP TIMESTAMP NOT NULL,
     CONSTRAINT pk_mem_key PRIMARY KEY (MEM_KEY)
);


/* SEQUENCES */

CREATE SEQUENCE status_seq
      START WITH 1 INCREMENT BY 1;

CREATE SEQUENCE tablespace_seq
      START WITH 1 INCREMENT BY 1;

CREATE SEQUENCE datafile_seq
      START WITH 1 INCREMENT BY 1;

CREATE SEQUENCE user_seq
      START WITH 1 INCREMENT BY 1;

CREATE SEQUENCE user_tablespace_seq
      START WITH 1 INCREMENT BY 1;

CREATE SEQUENCE role_seq
      START WITH 1 INCREMENT BY 1;

CREATE SEQUENCE user_role_seq
      START WITH 1 INCREMENT BY 1;

CREATE SEQUENCE sql_commands_seq
      START WITH 1 INCREMENT BY 1;

CREATE SEQUENCE cpu_seq
      START WITH 1 INCREMENT BY 1;

CREATE SEQUENCE memory_seq
      START WITH 1 INCREMENT BY 1;

/* TRIGGERS */

CREATE OR REPLACE TRIGGER inc_status
BEFORE INSERT ON STATUS
FOR EACH ROW
BEGIN 
  IF :NEW.STATUS_KEY IS NULL 
  THEN  
    :NEW.STATUS_KEY := status_seq.NEXTVAL;
    :NEW.TSTAMP := sysdate;
  END IF; 
END;
/

CREATE OR REPLACE TRIGGER inc_tablespace
BEFORE INSERT ON "TABLESPACE"
FOR EACH ROW
BEGIN 
  IF :NEW.TABLESPACE_KEY IS NULL 
  THEN  
    :NEW.TABLESPACE_KEY := tablespace_seq.NEXTVAL;
    :NEW.TSTAMP := sysdate;
  END IF; 
END;
/

CREATE OR REPLACE TRIGGER inc_datafile
BEFORE INSERT ON DATAFILE
FOR EACH ROW
BEGIN 
  IF :NEW.DATAFILE_KEY IS NULL 
  THEN  
    :NEW.DATAFILE_KEY := datafile_seq.NEXTVAL;
    :NEW.TSTAMP := sysdate;
  END IF; 
END;
/

CREATE OR REPLACE TRIGGER inc_user
BEFORE INSERT ON "USER"
FOR EACH ROW
BEGIN 
  IF :NEW.USER_KEY IS NULL 
  THEN  
    :NEW.USER_KEY := user_seq.NEXTVAL;
    :NEW.TSTAMP := sysdate;
  END IF; 
END;
/

CREATE OR REPLACE TRIGGER inc_user_tablespace
BEFORE INSERT ON USER_TABLESPACE
FOR EACH ROW
BEGIN 
  IF :NEW.USER_TABLESPACE_KEY IS NULL 
  THEN  
    :NEW.USER_TABLESPACE_KEY := user_tablespace_seq.NEXTVAL;
    :NEW.TSTAMP := sysdate;
  END IF; 
END;
/

CREATE OR REPLACE TRIGGER inc_role
BEFORE INSERT ON ROLE
FOR EACH ROW
BEGIN 
  IF :NEW.ROLE_KEY IS NULL 
  THEN  
    :NEW.ROLE_KEY := role_seq.NEXTVAL;
    :NEW.TSTAMP := sysdate;
  END IF; 
END;
/

CREATE OR REPLACE TRIGGER inc_user_role
BEFORE INSERT ON USER_ROLE
FOR EACH ROW
BEGIN 
  IF :NEW.USER_ROLE_KEY IS NULL 
  THEN  
    :NEW.USER_ROLE_KEY := user_role_seq.NEXTVAL;
    :NEW.TSTAMP := sysdate;
  END IF; 
END;
/

CREATE OR REPLACE TRIGGER inc_sql_commands
BEFORE INSERT ON SQL_COMMANDS
FOR EACH ROW
BEGIN 
  IF :NEW.SQL_COMMANDS_KEY IS NULL 
  THEN  
    :NEW.SQL_COMMANDS_KEY := sql_commands_seq.NEXTVAL;
    :NEW.TSTAMP := sysdate;
  END IF; 
END;
/

CREATE OR REPLACE TRIGGER inc_cpu
BEFORE INSERT ON CPU
FOR EACH ROW
BEGIN 
  IF :NEW.CPU_KEY IS NULL 
  THEN  
    :NEW.CPU_KEY := cpu_seq.NEXTVAL;
    :NEW.TSTAMP := sysdate;
  END IF; 
END;
/

CREATE OR REPLACE TRIGGER inc_memory
BEFORE INSERT ON MEMORY
FOR EACH ROW
BEGIN 
  IF :NEW.MEM_KEY IS NULL 
  THEN  
    :NEW.MEM_KEY := memory_seq.NEXTVAL;
    :NEW.TSTAMP := sysdate;
  END IF; 
END;
/

CREATE OR REPLACE TRIGGER join_user_tablespace   
BEFORE INSERT ON USER_TABLESPACE
FOR EACH ROW
DECLARE 
    uk NUMBER;
    tk NUMBER;
BEGIN 
  SELECT cu.USER_KEY INTO uk FROM CUR_USER cu WHERE cu.USER_ID = :NEW.USER_KEY;
  SELECT ct.TABLESPACE_KEY INTO tk FROM CUR_TABLESPACE ct WHERE ct.TABLESPACE_ID = :NEW.TABLESPACE_KEY;
  :NEW.USER_KEY := uk;
  :NEW.TABLESPACE_KEY := tk;
END;
/

CREATE OR REPLACE TRIGGER join_user_role   
BEFORE INSERT ON USER_ROLE
FOR EACH ROW
DECLARE 
    uk NUMBER;
    rk NUMBER;
BEGIN 
  SELECT cu.USER_KEY INTO uk FROM CUR_USER cu WHERE cu.USER_ID = :NEW.USER_KEY;
  SELECT ct.ROLE_KEY INTO rk FROM CUR_ROLE ct WHERE ct.ROLE_ID = :NEW.ROLE_KEY;
  :NEW.USER_KEY := uk;
  :NEW.ROLE_KEY := rk;
END;
/

CREATE OR REPLACE TRIGGER join_user_role   
BEFORE INSERT ON USER_ROLE
FOR EACH ROW
DECLARE 
    uk NUMBER;
    rk NUMBER;
BEGIN 
  SELECT cu.USER_KEY INTO uk FROM CUR_USER cu WHERE cu.USER_ID = :NEW.USER_KEY;
  SELECT ct.ROLE_KEY INTO rk FROM CUR_ROLE ct WHERE ct.ROLE_ID = :NEW.ROLE_KEY;
  :NEW.USER_KEY := uk;
  :NEW.ROLE_KEY := rk;
END; 
/

CREATE OR REPLACE TRIGGER join_datafile_tablespace
BEFORE INSERT ON DATAFILE
FOR EACH ROW
DECLARE 
    tk NUMBER;
BEGIN 
  SELECT t.TABLESPACE_KEY INTO tk FROM CUR_TABLESPACE t WHERE t.TABLESPACE_ID = :NEW.TABLESPACE_KEY;
  :NEW.TABLESPACE_KEY := tk;
END; 
/

/* VIEWS */

CREATE OR REPLACE VIEW CUR_ROLE 
AS SELECT * FROM ROLE t WHERE t.TSTAMP = (SELECT MAX(TSTAMP) FROM ROLE);

CREATE OR REPLACE VIEW CUR_MEMORY
AS SELECT * FROM DATAFILE t WHERE t.TSTAMP = (SELECT MAX(TSTAMP) FROM DATAFILE);

CREATE OR REPLACE VIEW CUR_TABLESPACE  
AS SELECT * FROM "TABLESPACE" t WHERE t.TSTAMP = (SELECT MAX(TSTAMP) FROM "TABLESPACE");

CREATE OR REPLACE  VIEW CUR_ROLE 
AS SELECT * FROM "ROLE" t WHERE t.TSTAMP = (SELECT MAX(TSTAMP) FROM "ROLE");

CREATE OR REPLACE VIEW CUR_USER_TABLESPACE 
AS SELECT * FROM USER_TABLESPACE t WHERE t.TSTAMP = (SELECT MAX(TSTAMP) FROM USER_TABLESPACE);

CREATE OR REPLACE VIEW CUR_USER  
AS SELECT * FROM "USER" t WHERE t.TSTAMP = (SELECT MAX(TSTAMP) FROM "USER");

CREATE OR REPLACE VIEW CUR_DATAFILE
AS SELECT * FROM DATAFILE t WHERE t.TSTAMP = (SELECT MAX(TSTAMP) FROM DATAFILE);

CREATE OR REPLACE VIEW CUR_MEMORY
AS SELECT * FROM MEMORY ORDER BY MEM_KEY DESC FETCH FIRST 1 ROWS ONLY;

CREATE OR REPLACE VIEW CUR_CPU
AS SELECT * FROM CPU ORDER BY CPU_KEY DESC FETCH FIRST 1 ROWS ONLY;

CREATE OR REPLACE VIEW CUR_STATUS
AS SELECT * FROM STATUS ORDER BY STATUS_KEY DESC FETCH FIRST 1 ROWS ONLY;